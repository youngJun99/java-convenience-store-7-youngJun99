
## 🔧 기능 구현 목록

### 매장

- 매장은 상품들을 가지고 있다.
- 매장은 매장의 보유 상품들을 DTO를 통해 제공할 수 있다.
- 매장은 주문에 따라서 상품들을 장바구니에 담는다
- 매장은 보유하지 않은 재고의 주문에 대해서 에러를 출력한다.
- 매장은 장바구니를 확정하면 주문을 수행하여 내부 상품들의 재고에 반영한다.

### 상품

- 상품은 이름, 프로모션, 프로모션 재고, 일반재고를 가진 객체다
- 상품은 이름을 반환할 수 있다.
- 상품은 재고를 DTO를 통해서 제공할 수 있다.
- 상품은 주문을 받으면 프로모션을 고려하여 장바구니 상품를 반환한다.
- 상품은 장바구니를 확정하여 재고를 줄일 수 있다.
- 상품의 리필기능은 구현하지 않는다

### 장바구니 상품

- 장바구니 상품은 이름, 승인여부, 프로모션 처리 재고량, 일반 재고량, 수령가능한 보너스 재고량에 대한 정보를 가지고 있다.
- 장바구니 상품은 외부에서 생성할 수 있는 정적 매서드로 생성 가능해야 한다
- 장바구니 상품은 내부 정보를 직접적으로 열람할 수 있어야 한다.
- 장바구니 상품은 주문 승인 요청을 DTO로 제공할 수 있다.
- 장바구니 상품은 주문 승인 대답을 DTO로 받아서 처리할 수 있다.

### 장바구니

- 장바구니 안에는 가구매 상품(장바구니 상품)들이 들어있다.
- 장바구니는 모든 항목들이 승인 상태인지 확인할 수 있다.
- 장바구니는 승인되지 않은 상품들에 한해서 승인 요청 DTO를 출력할 수 있다.
- 장바구니는 승인 요청에 대한 DTO를 받아서 장바구니 상품들을 요청에 맞게 조작할 수 있다.

### 프로모션 인터페이스/구현체

- 프로모션은 Interface로 구현된다
- 프로모션은 이름을 반환한다.
- 프로모션은 날짜를 받아서 프로모션 가능한지 확인할 수 있다.
- 프로모션은 프로모션 재고를 입력받아 장바구니 상품을 만들수 있다. ( 장바구니 상품 생성 로직이 중요! )
- 프로모션은 재고를 입력받으면 몇개의 상품을 무료로 제공하는지 계산할 수 있다.
- 프로모션이 없는 것도 NullPromotion으로 구현한다.

### 멤버십

- 멤버십은 인터페이스로 구현하되 여러가지가 쓰이지 않음으로 DefaultMembership을 구현체로 둔다.
- 멤버십은 할인 비율, 최대할인 제한을 상수로 가지고 있다.
- 멤버십은 돈을 입력값으로 받고 할인값을 반환한다.

### 매장 제작 펙토리

- 부수적인 부분이라 간단하게 구현한다.
- 프로모션을 만드는 펙토리와 매장을 만드는 펙토리를 구분한다.
- 경로를 통해서 입력받을 수 있도록 구현한다.
- 기본 md 형태에 따라서 입력받을 수 있도록 한다.

### View/Handler

- 뷰에서는 입력과 출력만을 담당한다.
- InputHandler에서는 유효성 검사를 담당하는 클래스를 분리해 입력받고, 정제와 파싱을 진행한다.
- OutputHandler에서는 OutputView로 가기전 DTO의 정보를 처리하는 정제의 과정을 거친다.
---

## ✅ FeedBack 체크 리스트

## 1️⃣ 가독성

- [x]  작명의 의미 전달력 + Number 같이 다른것과 겹치는거 사용 x
- [x]  코드 포맷팅 (IntelliJ IDEA: ⌥⌘L)
- [x]  요약 설명은 Comment에, ReadMe는 꼼꼼히하고 상시 업데이트
- [x]  구현 순서를 깔끔하게 하였는가

## 2️⃣ 코딩 습관

- [x]  필요하다면 싱글톤을 적용하기 -> Config의 관리 밖의 것들을 싱글톤으로 처리
- [x]  안 쓰는 Importation 삭제
- [x]  변수명에 자료형을 쓰지 않는다
- [x]  변수명에 불용어를 넣지 않는다
- [x]  if 안에 부정문을 줄여보자
- [x]  와일드 카드를 지양한다 -> 필요없는 경우 사용 x
- [x]  commit의 가독성을 놓치지 말자

## 3️⃣ 설계 중점 사항

- [x]  Config를 써보자
- [x]  참조로 추적되는 데이터형 getter 지양 → DTO 사용 (record 타입), 방어적 복사 대안, 수정 불가 객체 return
- [x]  DTO는 의미있게 사용한다(+ Dto 내부에서 생성 처리)
- [x]  구현 방식에 집중해서 과제 자체에 대한 예외들을 빼먹지 말 것
- [x]  상수가 연관성이 있다면 enum 사용
- [x]  메서드는 한 가지 일만 처리한다 (10 줄 이하 이건 메인 코드도 동일) -> 최대한 노력
- [x]  마지막 프로그래밍 요구 사항 지켰는지 check (예외를 잘보자)
- [x]  많이 의존 당한다면 interface의 근거가 충분하다 (+ 인터페이스화 할 근거가 필요 가령, 활용성이 높다) 
- [x]  객체는 객체에서의 역할에 충실하고 나머지는 service에 존재한다
- [x]  validation은 객체 자체의 정체성, 유효성 검사, 파싱, 그리고 정제를 분리해서 생각한다.
- [x]  view의 역할을 침범하지 말자 ex) 포메팅
- [x]  getter를 되도록 이면 지양한다 캡슐화에 조금 더 신경 써야 할 것 같다.
- [x]  필드를 줄이기 위해 노력하자

## 4️⃣ Test

- [x]  test coverage check 
- [x]  테스트 자체에서 메서드를 만들거나 여러 기능을 사용해 중복 테스트 줄이기
- [x]  2주차 feedback 테스트 메서드 참고 자료 활용
- [x]  UI(System.out, System.in, Scanner) 로직은 제외한다 (굳이 사용할 필요가 없었다)
- [x]  Interface 적극 사용 → 테스트 대역이라면 따로 분리하자
- [x]  테스트를 하기 용이하게 코드를 작성한다
- [x]  TDD에 대한 시도를 해본다 -> 확정된 설계를 하면 유용하겠지만 너무 오래 걸렸다.
- [x]  공백 테스트는 \n \t 같은 것도 하자
- [x]  예외 테스트를 집중적으로 하자
- [x]  테스트 코드도 가독성을 신경써야 한다

## 5️⃣ 기타

- [x]  stackOverflow를 고려한다
- [x]  enum Map을 고려한다 -> 사용할 필요가 없었다
- [x]  Java 8의 인터페이스 default 기능을 고려한다 (like 상속) ->미사용
- [x]  필요하다면 상속을 사용해보자 -> 미사용
- [x]  꼭 필요한 경우가 아니라면 상수 처리할 필요가 없을 것 같다
- [x]  숫자 구분자 1_000_000 를 사용하면 가독성이 좋다
- [x]  서비스가 필드를 가지지 않도록 만들어보자 -> 이건 static이 아니라면 불가능해 보인다. 대신 도메인을 필드로 가지지 않도록 하였다
- [x]  줄 바꿈이 필요하다면 `System.lineSeparator()` 을 써보자
- [x]  예외 처리를 흐름 제어용으로 사용하지 말 것


